### 一.接口

* 与Java一致，一个类可以实现任意多个接口，但是只能继承一个类

* override修饰符用来标注被重写的父类或者接口的方法和属性

* Kotlin中强制要求写override

* 接口方法可以有一个默认实现，Java中需要标注**default**关键字，Kotlin无特殊注解，只需要提供**方法体**
* 接口中不能使用final，open，abstract，接口中的成员始终open，不能声明为final
  * 接口中成员始终为open，所有open不需要使用，final不能使用
  * 若一个方法默认没有函数题，它就是abstract的，所以abstract也不是必须的





##### 如果类实现了两个接口，并且两个接口中都有默认实现的同名方法，必须提供一个显式实现否则编译器便会报错



* 调用父类型继承的实现，使用关键字**super**

```kotlin
override fun showOff() = super<Clickable>.showOff()//调用一个继承的实现
```

```kotlin
override fun showOff() {//调用多个继承的实现
    super<Clickable>.showOff()
    super<Focusable>.showOff()
}
```





### 二.类

* Java的类和方法默认是**open**的，Kotlin默认类，属性，方法都是**final**的

* 若期望这个类可被继承，可在类前添加**open修饰符**，此外需要给每一个**可被重写的属性和方法**都添加open修饰符

* 如果你重写了一个基类或者接口的成员，**重写了的成员同样默认open**，如果想阻止子类继承，**显示添加final**



#### 1.类中访问修饰符

![image-20210916143709053](C:\Users\860119016\AppData\Roaming\Typora\typora-user-images\image-20210916143709053.png)



#### 2.可见性修饰符

* **Java中默认的修饰符是default（包私有），Kotlin中默认修饰符public**
* **internal 模块中可见，一个模块就是一组一起编译的Kotlin文件**
* **protected修饰符**
  * *Java可以从同一个包中访问一个protected成员*
  * *Kotlin中 protect成员只在类和它的子类可见*
  * *Kotlin中类的扩展函数不可访问它的private和protected成员*

![image-20210916145535981](C:\Users\860119016\AppData\Roaming\Typora\typora-user-images\image-20210916145535981.png)



### 三 内部类和嵌套类

#### 1.Java内部类会因持有外部类而破坏序列化

```kotlin
interface State :Serializable//接口interface可序列化
interface View{
    fun getCurrentState():State
    fun restoreState(state:State)
}
```

```java
public class Button implements View {
    @NotNull
    @Override
    public State getCurrentState() {
        return new ButtonState();
    }

    @Override
    public void restoreState(@NotNull State state) {

    }

    public class ButtonState implements State {
        //当在一个类中声明另一个类时，它会默认变成内部类
        //ButtonState隐式存储了它外部类的引用 
    }
}
```

```java
public static void main(String[] args) {
        Button button = new Button();
        Button.ButtonState buttonState = (Button.ButtonState) button.getCurrentState();
        try {
            FileOutputStream fileOut = new FileOutputStream("C:\\Users\\860119016\\Desktop\\新建文件夹");
            ObjectOutputStream out = new ObjectOutputStream(fileOut);
            out.writeObject(buttonState);
            out.close();
            fileOut.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
}
```

* ##### Button 不可序列化，Button的引用破坏了ButtonState的序列化

* ##### 为ButtonState可序列化，将类声明为static,因为static类没有指向外部类的引用

```java
java.io.NotSerializableException: nestclass.Button
	at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1184)
	at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348)
	at nestclass.Test.main(Test.java:13)
```



**Java补充**

内部类的对象有一个隐式引用，它引用了实例化该内部对象的外围类对象。通过这个指针，可以访问外围类对象的全部状态，static内部类没有这种附加指针《Java核心卷 I》

内部类可以对同一个包中的其他类隐藏起来《Java核心卷 I》

#### 2.Kotlin的默认行为与Java相反，直接声明在类中的是嵌套类，若需要变成内部类来持有外部类的引用则需要使用inner修饰符

![image-20210917145753170](C:\Users\860119016\AppData\Roaming\Typora\typora-user-images\image-20210917145753170.png)

* *Kotlin中在内部类引用外部类使用this@外部类*

  ```kotlin
  class Button : View {
      override fun getCurrentState(): State {
          TODO("Not yet implemented")
      }
  
      override fun restoreState(state: State) {
          TODO("Not yet implemented")
      }
  
      inner class ButtonState : State {
          fun getOuterReference(): Button = this@Button
      }
  }
  ```



#### 3.密封类：定义受限的类继承解构

*1.潜在问题：when表达式必须提供一个else分支处理没有任何其他分支能匹配默认情况，这会导致如果忘记添加了新分支，**会选择默认的选项**，这有可能导致潜在的bug*

* Kotlin的解决方法：**sealed类（密封类）**，对可能创建的子类做出严格的限制，所有的直接子类必须嵌套在父类中







### Kotlin 类

* 初始化类

  *1.constructor关键字开始一个主构造方法或从构造方法的声明，init 关键字引入初始化语句块*

```kotlin
//constructor关键字开始一个主构造方法或从构造方法的声明
class Child constructor( _name:String){//主构造方法（类体外部声明）
      private val name : String 
      init {//init 关键字引入初始化语句块
          name = _name
      }
  }
```

​     *2.参数初始化*

```kotlin
  class Child constructor( _name:String){//若没有注解或可见性修饰符constructor可省略
     val name  = _name//用参数直接初始化属性，不需要用init来初始化
  }
```

​    *3.使用构造方法参数初始化*

```kotlin
  class Child constructor(val _name:String)//可以把val关键字放在参数前，意味着相应的属性会用构造方法的参数来初始化
```

​    *4.声明默认值*
```kotlin
class Child constructor( _name:String,age : Int = 5)//可以声明默认值
```
​    *5.若主构造方法同样需要初始化父类，可以提供父类构造方法参数做到这一点*

```kotlin
class Child constructor( _name:String,age : Int = 5):Super(_name)
```



* 如果没有给类声明任何构造方法，将会生成一个不做任何事情的默认构造方法

  ```kotlin
  class Child
  ```

* 子类继承父类必须显示调用父类构造方法，即使它没有任何参数

  ```kotlin
  class Child :Super()
  ```

* 要确保类不被其他代码实例化，必须把构造方法标记为private

  ```kotlin
  class Child private constructor()
  ```

